// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

public enum pahkat_WindowsExecutableFlag: UInt8, Enum, Verifiable {
  public typealias T = UInt8
  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case targetsystem = 0
  case targetuser = 1
  case requiresrebootonupdate = 32
  case requiresrebootonuninstall = 64
  case requiresrebootoninstall = 128

  public static var max: pahkat_WindowsExecutableFlag { return .requiresrebootoninstall }
  public static var min: pahkat_WindowsExecutableFlag { return .targetsystem }
}

public enum pahkat_WindowsExecutableKind: UInt8, Enum, Verifiable {
  public typealias T = UInt8
  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case msi = 1
  case inno = 2
  case nsis = 3

  public static var max: pahkat_WindowsExecutableKind { return .nsis }
  public static var min: pahkat_WindowsExecutableKind { return .none_ }
}

public enum pahkat_MacOSPackageFlag: UInt8, Enum, Verifiable {
  public typealias T = UInt8
  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case targetsystem = 0
  case targetuser = 1
  case requiresrebootonupdate = 32
  case requiresrebootonuninstall = 64
  case requiresrebootoninstall = 128

  public static var max: pahkat_MacOSPackageFlag { return .requiresrebootoninstall }
  public static var min: pahkat_MacOSPackageFlag { return .targetsystem }
}

public enum pahkat_Payload: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case windowsexecutable = 1
  case macospackage = 2
  case tarballpackage = 3

  public static var max: pahkat_Payload { return .tarballpackage }
  public static var min: pahkat_Payload { return .none_ }
}

public enum pahkat_Package: UInt8, UnionEnum {
  public typealias T = UInt8

  public init?(value: T) {
    self.init(rawValue: value)
  }

  public static var byteSize: Int { return MemoryLayout<UInt8>.size }
  public var value: UInt8 { return self.rawValue }
  case none_ = 0
  case descriptor = 1
  case synthetic = 2
  case redirect = 3

  public static var max: pahkat_Package { return .redirect }
  public static var min: pahkat_Package { return .none_ }
}

public struct pahkat_WindowsExecutable: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsWindowsExecutable(bb: ByteBuffer) -> pahkat_WindowsExecutable { return pahkat_WindowsExecutable(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case url = 4
    case productCode = 6
    case size = 8
    case installedSize = 10
    case flags = 12
    case kind = 14
    case args = 16
    case uninstallArgs = 18
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var url: String! { let o = _accessor.offset(VTOFFSET.url.v); return _accessor.string(at: o) }
  public var urlSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.url.v) }
  public var productCode: String! { let o = _accessor.offset(VTOFFSET.productCode.v); return _accessor.string(at: o) }
  public var productCodeSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.productCode.v) }
  public var size: UInt64 { let o = _accessor.offset(VTOFFSET.size.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public var installedSize: UInt64 { let o = _accessor.offset(VTOFFSET.installedSize.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public var flags: UInt8 { let o = _accessor.offset(VTOFFSET.flags.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var kind: pahkat_WindowsExecutableKind { let o = _accessor.offset(VTOFFSET.kind.v); return o == 0 ? .none_ : pahkat_WindowsExecutableKind(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public var args: String? { let o = _accessor.offset(VTOFFSET.args.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var argsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.args.v) }
  public var uninstallArgs: String? { let o = _accessor.offset(VTOFFSET.uninstallArgs.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var uninstallArgsSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.uninstallArgs.v) }
  public static func startWindowsExecutable(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 8) }
  public static func add(url: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: url, at: VTOFFSET.url.p) }
  public static func add(productCode: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: productCode, at: VTOFFSET.productCode.p) }
  public static func add(size: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: size, def: 0, at: VTOFFSET.size.p) }
  public static func add(installedSize: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: installedSize, def: 0, at: VTOFFSET.installedSize.p) }
  public static func add(flags: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: flags, def: 0, at: VTOFFSET.flags.p) }
  public static func add(kind: pahkat_WindowsExecutableKind, _ fbb: inout FlatBufferBuilder) { fbb.add(element: kind.rawValue, def: 0, at: VTOFFSET.kind.p) }
  public static func add(args: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: args, at: VTOFFSET.args.p) }
  public static func add(uninstallArgs: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: uninstallArgs, at: VTOFFSET.uninstallArgs.p) }
  public static func endWindowsExecutable(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6]); return end }
  public static func createWindowsExecutable(
    _ fbb: inout FlatBufferBuilder,
    urlOffset url: Offset = Offset(),
    productCodeOffset productCode: Offset = Offset(),
    size: UInt64 = 0,
    installedSize: UInt64 = 0,
    flags: UInt8 = 0,
    kind: pahkat_WindowsExecutableKind = .none_,
    argsOffset args: Offset = Offset(),
    uninstallArgsOffset uninstallArgs: Offset = Offset()
  ) -> Offset {
    let __start = pahkat_WindowsExecutable.startWindowsExecutable(&fbb)
    pahkat_WindowsExecutable.add(url: url, &fbb)
    pahkat_WindowsExecutable.add(productCode: productCode, &fbb)
    pahkat_WindowsExecutable.add(size: size, &fbb)
    pahkat_WindowsExecutable.add(installedSize: installedSize, &fbb)
    pahkat_WindowsExecutable.add(flags: flags, &fbb)
    pahkat_WindowsExecutable.add(kind: kind, &fbb)
    pahkat_WindowsExecutable.add(args: args, &fbb)
    pahkat_WindowsExecutable.add(uninstallArgs: uninstallArgs, &fbb)
    return pahkat_WindowsExecutable.endWindowsExecutable(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.url.p, fieldName: "url", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.productCode.p, fieldName: "productCode", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.size.p, fieldName: "size", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.installedSize.p, fieldName: "installedSize", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.flags.p, fieldName: "flags", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.kind.p, fieldName: "kind", required: false, type: pahkat_WindowsExecutableKind.self)
    try _v.visit(field: VTOFFSET.args.p, fieldName: "args", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.uninstallArgs.p, fieldName: "uninstallArgs", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct pahkat_MacOSPackage: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsMacOSPackage(bb: ByteBuffer) -> pahkat_MacOSPackage { return pahkat_MacOSPackage(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case url = 4
    case pkgId = 6
    case size = 8
    case installedSize = 10
    case flags = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var url: String! { let o = _accessor.offset(VTOFFSET.url.v); return _accessor.string(at: o) }
  public var urlSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.url.v) }
  public var pkgId: String! { let o = _accessor.offset(VTOFFSET.pkgId.v); return _accessor.string(at: o) }
  public var pkgIdSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.pkgId.v) }
  public var size: UInt64 { let o = _accessor.offset(VTOFFSET.size.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public var installedSize: UInt64 { let o = _accessor.offset(VTOFFSET.installedSize.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public var flags: UInt8 { let o = _accessor.offset(VTOFFSET.flags.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public static func startMacOSPackage(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(url: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: url, at: VTOFFSET.url.p) }
  public static func add(pkgId: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: pkgId, at: VTOFFSET.pkgId.p) }
  public static func add(size: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: size, def: 0, at: VTOFFSET.size.p) }
  public static func add(installedSize: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: installedSize, def: 0, at: VTOFFSET.installedSize.p) }
  public static func add(flags: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: flags, def: 0, at: VTOFFSET.flags.p) }
  public static func endMacOSPackage(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 6]); return end }
  public static func createMacOSPackage(
    _ fbb: inout FlatBufferBuilder,
    urlOffset url: Offset = Offset(),
    pkgIdOffset pkgId: Offset = Offset(),
    size: UInt64 = 0,
    installedSize: UInt64 = 0,
    flags: UInt8 = 0
  ) -> Offset {
    let __start = pahkat_MacOSPackage.startMacOSPackage(&fbb)
    pahkat_MacOSPackage.add(url: url, &fbb)
    pahkat_MacOSPackage.add(pkgId: pkgId, &fbb)
    pahkat_MacOSPackage.add(size: size, &fbb)
    pahkat_MacOSPackage.add(installedSize: installedSize, &fbb)
    pahkat_MacOSPackage.add(flags: flags, &fbb)
    return pahkat_MacOSPackage.endMacOSPackage(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.url.p, fieldName: "url", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.pkgId.p, fieldName: "pkgId", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.size.p, fieldName: "size", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.installedSize.p, fieldName: "installedSize", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.flags.p, fieldName: "flags", required: false, type: UInt8.self)
    _v.finish()
  }
}

public struct pahkat_TarballPackage: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsTarballPackage(bb: ByteBuffer) -> pahkat_TarballPackage { return pahkat_TarballPackage(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case url = 4
    case size = 6
    case installedSize = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var url: String! { let o = _accessor.offset(VTOFFSET.url.v); return _accessor.string(at: o) }
  public var urlSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.url.v) }
  public var size: UInt64 { let o = _accessor.offset(VTOFFSET.size.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public var installedSize: UInt64 { let o = _accessor.offset(VTOFFSET.installedSize.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public static func startTarballPackage(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(url: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: url, at: VTOFFSET.url.p) }
  public static func add(size: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: size, def: 0, at: VTOFFSET.size.p) }
  public static func add(installedSize: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: installedSize, def: 0, at: VTOFFSET.installedSize.p) }
  public static func endTarballPackage(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createTarballPackage(
    _ fbb: inout FlatBufferBuilder,
    urlOffset url: Offset = Offset(),
    size: UInt64 = 0,
    installedSize: UInt64 = 0
  ) -> Offset {
    let __start = pahkat_TarballPackage.startTarballPackage(&fbb)
    pahkat_TarballPackage.add(url: url, &fbb)
    pahkat_TarballPackage.add(size: size, &fbb)
    pahkat_TarballPackage.add(installedSize: installedSize, &fbb)
    return pahkat_TarballPackage.endTarballPackage(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.url.p, fieldName: "url", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.size.p, fieldName: "size", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.installedSize.p, fieldName: "installedSize", required: false, type: UInt64.self)
    _v.finish()
  }
}

public struct pahkat_Target: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsTarget(bb: ByteBuffer) -> pahkat_Target { return pahkat_Target(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case platform = 4
    case payloadType = 6
    case payload = 8
    case dependenciesKeys = 10
    case dependenciesValues = 12
    case arch = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var platform: String! { let o = _accessor.offset(VTOFFSET.platform.v); return _accessor.string(at: o) }
  public var platformSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.platform.v) }
  public var payloadType: pahkat_Payload { let o = _accessor.offset(VTOFFSET.payloadType.v); return o == 0 ? .none_ : pahkat_Payload(rawValue: _accessor.readBuffer(of: UInt8.self, at: o)) ?? .none_ }
  public func payload<T: FlatbuffersInitializable>(type: T.Type) -> T! { let o = _accessor.offset(VTOFFSET.payload.v); return _accessor.union(o) }
  public var dependenciesKeysCount: Int32 { let o = _accessor.offset(VTOFFSET.dependenciesKeys.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func dependenciesKeys(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.dependenciesKeys.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var dependenciesValuesCount: Int32 { let o = _accessor.offset(VTOFFSET.dependenciesValues.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func dependenciesValues(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.dependenciesValues.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var arch: String? { let o = _accessor.offset(VTOFFSET.arch.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var archSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.arch.v) }
  public static func startTarget(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(platform: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: platform, at: VTOFFSET.platform.p) }
  public static func add(payloadType: pahkat_Payload, _ fbb: inout FlatBufferBuilder) { fbb.add(element: payloadType.rawValue, def: 0, at: VTOFFSET.payloadType.p) }
  public static func add(payload: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: payload, at: VTOFFSET.payload.p) }
  public static func addVectorOf(dependenciesKeys: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dependenciesKeys, at: VTOFFSET.dependenciesKeys.p) }
  public static func addVectorOf(dependenciesValues: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: dependenciesValues, at: VTOFFSET.dependenciesValues.p) }
  public static func add(arch: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: arch, at: VTOFFSET.arch.p) }
  public static func endTarget(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4, 8]); return end }
  public static func createTarget(
    _ fbb: inout FlatBufferBuilder,
    platformOffset platform: Offset = Offset(),
    payloadType: pahkat_Payload = .none_,
    payloadOffset payload: Offset = Offset(),
    dependenciesKeysVectorOffset dependenciesKeys: Offset = Offset(),
    dependenciesValuesVectorOffset dependenciesValues: Offset = Offset(),
    archOffset arch: Offset = Offset()
  ) -> Offset {
    let __start = pahkat_Target.startTarget(&fbb)
    pahkat_Target.add(platform: platform, &fbb)
    pahkat_Target.add(payloadType: payloadType, &fbb)
    pahkat_Target.add(payload: payload, &fbb)
    pahkat_Target.addVectorOf(dependenciesKeys: dependenciesKeys, &fbb)
    pahkat_Target.addVectorOf(dependenciesValues: dependenciesValues, &fbb)
    pahkat_Target.add(arch: arch, &fbb)
    return pahkat_Target.endTarget(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.platform.p, fieldName: "platform", required: true, type: ForwardOffset<String>.self)
    try _v.visit(unionKey: VTOFFSET.payloadType.p, unionField: VTOFFSET.payload.p, unionKeyName: "payloadType", fieldName: "payload", required: true, completion: { (verifier, key: pahkat_Payload, pos) in
      switch key {
      case .none_:
        break // NOTE - SWIFT doesnt support none
      case .windowsexecutable:
        try ForwardOffset<pahkat_WindowsExecutable>.verify(&verifier, at: pos, of: pahkat_WindowsExecutable.self)
      case .macospackage:
        try ForwardOffset<pahkat_MacOSPackage>.verify(&verifier, at: pos, of: pahkat_MacOSPackage.self)
      case .tarballpackage:
        try ForwardOffset<pahkat_TarballPackage>.verify(&verifier, at: pos, of: pahkat_TarballPackage.self)
      }
    })
    try _v.visit(field: VTOFFSET.dependenciesKeys.p, fieldName: "dependenciesKeys", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.dependenciesValues.p, fieldName: "dependenciesValues", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.arch.p, fieldName: "arch", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct pahkat_Release: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsRelease(bb: ByteBuffer) -> pahkat_Release { return pahkat_Release(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case versionType = 4
    case version = 6
    case target = 8
    case channel = 10
    case authors = 12
    case license = 14
    case licenseUrl = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var versionType: UInt8 { let o = _accessor.offset(VTOFFSET.versionType.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public var version: String! { let o = _accessor.offset(VTOFFSET.version.v); return _accessor.string(at: o) }
  public var versionSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.version.v) }
  public var targetCount: Int32 { let o = _accessor.offset(VTOFFSET.target.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func target(at index: Int32) -> pahkat_Target? { let o = _accessor.offset(VTOFFSET.target.v); return o == 0 ? nil : pahkat_Target(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var channel: String? { let o = _accessor.offset(VTOFFSET.channel.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var channelSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.channel.v) }
  public var authorsCount: Int32 { let o = _accessor.offset(VTOFFSET.authors.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func authors(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.authors.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var license: String? { let o = _accessor.offset(VTOFFSET.license.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var licenseSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.license.v) }
  public var licenseUrl: String? { let o = _accessor.offset(VTOFFSET.licenseUrl.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var licenseUrlSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.licenseUrl.v) }
  public static func startRelease(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(versionType: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: versionType, def: 0, at: VTOFFSET.versionType.p) }
  public static func add(version: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: version, at: VTOFFSET.version.p) }
  public static func addVectorOf(target: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: target, at: VTOFFSET.target.p) }
  public static func add(channel: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: channel, at: VTOFFSET.channel.p) }
  public static func addVectorOf(authors: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: authors, at: VTOFFSET.authors.p) }
  public static func add(license: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: license, at: VTOFFSET.license.p) }
  public static func add(licenseUrl: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: licenseUrl, at: VTOFFSET.licenseUrl.p) }
  public static func endRelease(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [6]); return end }
  public static func createRelease(
    _ fbb: inout FlatBufferBuilder,
    versionType: UInt8 = 0,
    versionOffset version: Offset = Offset(),
    targetVectorOffset target: Offset = Offset(),
    channelOffset channel: Offset = Offset(),
    authorsVectorOffset authors: Offset = Offset(),
    licenseOffset license: Offset = Offset(),
    licenseUrlOffset licenseUrl: Offset = Offset()
  ) -> Offset {
    let __start = pahkat_Release.startRelease(&fbb)
    pahkat_Release.add(versionType: versionType, &fbb)
    pahkat_Release.add(version: version, &fbb)
    pahkat_Release.addVectorOf(target: target, &fbb)
    pahkat_Release.add(channel: channel, &fbb)
    pahkat_Release.addVectorOf(authors: authors, &fbb)
    pahkat_Release.add(license: license, &fbb)
    pahkat_Release.add(licenseUrl: licenseUrl, &fbb)
    return pahkat_Release.endRelease(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.versionType.p, fieldName: "versionType", required: false, type: UInt8.self)
    try _v.visit(field: VTOFFSET.version.p, fieldName: "version", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.target.p, fieldName: "target", required: false, type: ForwardOffset<Vector<ForwardOffset<pahkat_Target>, pahkat_Target>>.self)
    try _v.visit(field: VTOFFSET.channel.p, fieldName: "channel", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.authors.p, fieldName: "authors", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.license.p, fieldName: "license", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.licenseUrl.p, fieldName: "licenseUrl", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct pahkat_Descriptor: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsDescriptor(bb: ByteBuffer) -> pahkat_Descriptor { return pahkat_Descriptor(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case id = 4
    case release = 6
    case nameKeys = 8
    case nameValues = 10
    case descriptionKeys = 12
    case descriptionValues = 14
    case tags = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var id: String! { let o = _accessor.offset(VTOFFSET.id.v); return _accessor.string(at: o) }
  public var idSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.id.v) }
  public var releaseCount: Int32 { let o = _accessor.offset(VTOFFSET.release.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func release(at index: Int32) -> pahkat_Release? { let o = _accessor.offset(VTOFFSET.release.v); return o == 0 ? nil : pahkat_Release(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var nameKeysCount: Int32 { let o = _accessor.offset(VTOFFSET.nameKeys.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func nameKeys(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.nameKeys.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var nameValuesCount: Int32 { let o = _accessor.offset(VTOFFSET.nameValues.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func nameValues(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.nameValues.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var descriptionKeysCount: Int32 { let o = _accessor.offset(VTOFFSET.descriptionKeys.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func descriptionKeys(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.descriptionKeys.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var descriptionValuesCount: Int32 { let o = _accessor.offset(VTOFFSET.descriptionValues.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func descriptionValues(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.descriptionValues.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var tagsCount: Int32 { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func tags(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.tags.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public static func startDescriptor(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(id: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: id, at: VTOFFSET.id.p) }
  public static func addVectorOf(release: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: release, at: VTOFFSET.release.p) }
  public static func addVectorOf(nameKeys: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: nameKeys, at: VTOFFSET.nameKeys.p) }
  public static func addVectorOf(nameValues: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: nameValues, at: VTOFFSET.nameValues.p) }
  public static func addVectorOf(descriptionKeys: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: descriptionKeys, at: VTOFFSET.descriptionKeys.p) }
  public static func addVectorOf(descriptionValues: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: descriptionValues, at: VTOFFSET.descriptionValues.p) }
  public static func addVectorOf(tags: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: tags, at: VTOFFSET.tags.p) }
  public static func endDescriptor(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createDescriptor(
    _ fbb: inout FlatBufferBuilder,
    idOffset id: Offset = Offset(),
    releaseVectorOffset release: Offset = Offset(),
    nameKeysVectorOffset nameKeys: Offset = Offset(),
    nameValuesVectorOffset nameValues: Offset = Offset(),
    descriptionKeysVectorOffset descriptionKeys: Offset = Offset(),
    descriptionValuesVectorOffset descriptionValues: Offset = Offset(),
    tagsVectorOffset tags: Offset = Offset()
  ) -> Offset {
    let __start = pahkat_Descriptor.startDescriptor(&fbb)
    pahkat_Descriptor.add(id: id, &fbb)
    pahkat_Descriptor.addVectorOf(release: release, &fbb)
    pahkat_Descriptor.addVectorOf(nameKeys: nameKeys, &fbb)
    pahkat_Descriptor.addVectorOf(nameValues: nameValues, &fbb)
    pahkat_Descriptor.addVectorOf(descriptionKeys: descriptionKeys, &fbb)
    pahkat_Descriptor.addVectorOf(descriptionValues: descriptionValues, &fbb)
    pahkat_Descriptor.addVectorOf(tags: tags, &fbb)
    return pahkat_Descriptor.endDescriptor(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.id.p, fieldName: "id", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.release.p, fieldName: "release", required: false, type: ForwardOffset<Vector<ForwardOffset<pahkat_Release>, pahkat_Release>>.self)
    try _v.visit(field: VTOFFSET.nameKeys.p, fieldName: "nameKeys", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.nameValues.p, fieldName: "nameValues", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.descriptionKeys.p, fieldName: "descriptionKeys", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.descriptionValues.p, fieldName: "descriptionValues", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.tags.p, fieldName: "tags", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    _v.finish()
  }
}

public struct pahkat_Synthetic: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsSynthetic(bb: ByteBuffer) -> pahkat_Synthetic { return pahkat_Synthetic(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case todo = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var todo: UInt8 { let o = _accessor.offset(VTOFFSET.todo.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt8.self, at: o) }
  public static func startSynthetic(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(todo: UInt8, _ fbb: inout FlatBufferBuilder) { fbb.add(element: todo, def: 0, at: VTOFFSET.todo.p) }
  public static func endSynthetic(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSynthetic(
    _ fbb: inout FlatBufferBuilder,
    todo: UInt8 = 0
  ) -> Offset {
    let __start = pahkat_Synthetic.startSynthetic(&fbb)
    pahkat_Synthetic.add(todo: todo, &fbb)
    return pahkat_Synthetic.endSynthetic(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.todo.p, fieldName: "todo", required: false, type: UInt8.self)
    _v.finish()
  }
}

public struct pahkat_Redirect: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsRedirect(bb: ByteBuffer) -> pahkat_Redirect { return pahkat_Redirect(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case url = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var url: String! { let o = _accessor.offset(VTOFFSET.url.v); return _accessor.string(at: o) }
  public var urlSegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.url.v) }
  public static func startRedirect(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(url: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: url, at: VTOFFSET.url.p) }
  public static func endRedirect(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createRedirect(
    _ fbb: inout FlatBufferBuilder,
    urlOffset url: Offset = Offset()
  ) -> Offset {
    let __start = pahkat_Redirect.startRedirect(&fbb)
    pahkat_Redirect.add(url: url, &fbb)
    return pahkat_Redirect.endRedirect(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.url.p, fieldName: "url", required: true, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct pahkat_Packages: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_2_0_0() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  public static func getRootAsPackages(bb: ByteBuffer) -> pahkat_Packages { return pahkat_Packages(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case packagesKeys = 4
    case packagesValuesTypes = 6
    case packagesValues = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var packagesKeysCount: Int32 { let o = _accessor.offset(VTOFFSET.packagesKeys.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func packagesKeys(at index: Int32) -> String? { let o = _accessor.offset(VTOFFSET.packagesKeys.v); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
  public var packagesValuesTypesCount: Int32 { let o = _accessor.offset(VTOFFSET.packagesValuesTypes.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func packagesValuesTypes(at index: Int32) -> UInt8 { let o = _accessor.offset(VTOFFSET.packagesValuesTypes.v); return o == 0 ? 0 : _accessor.directRead(of: UInt8.self, offset: _accessor.vector(at: o) + index * 1) }
  public var packagesValuesTypes: [UInt8] { return _accessor.getVector(at: VTOFFSET.packagesValuesTypes.v) ?? [] }
  public var packagesValuesCount: Int32 { let o = _accessor.offset(VTOFFSET.packagesValues.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func packagesValues(at index: Int32) -> pahkat_Descriptor? { let o = _accessor.offset(VTOFFSET.packagesValues.v); return o == 0 ? nil : pahkat_Descriptor(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startPackages(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func addVectorOf(packagesKeys: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: packagesKeys, at: VTOFFSET.packagesKeys.p) }
  public static func addVectorOf(packagesValuesTypes: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: packagesValuesTypes, at: VTOFFSET.packagesValuesTypes.p) }
  public static func addVectorOf(packagesValues: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: packagesValues, at: VTOFFSET.packagesValues.p) }
  public static func endPackages(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createPackages(
    _ fbb: inout FlatBufferBuilder,
    packagesKeysVectorOffset packagesKeys: Offset = Offset(),
    packagesValuesTypesVectorOffset packagesValuesTypes: Offset = Offset(),
    packagesValuesVectorOffset packagesValues: Offset = Offset()
  ) -> Offset {
    let __start = pahkat_Packages.startPackages(&fbb)
    pahkat_Packages.addVectorOf(packagesKeys: packagesKeys, &fbb)
    pahkat_Packages.addVectorOf(packagesValuesTypes: packagesValuesTypes, &fbb)
    pahkat_Packages.addVectorOf(packagesValues: packagesValues, &fbb)
    return pahkat_Packages.endPackages(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.packagesKeys.p, fieldName: "packagesKeys", required: false, type: ForwardOffset<Vector<ForwardOffset<String>, String>>.self)
    try _v.visit(field: VTOFFSET.packagesValuesTypes.p, fieldName: "packagesValuesTypes", required: false, type: ForwardOffset<Vector<UInt8, UInt8>>.self)
    try _v.visit(field: VTOFFSET.packagesValues.p, fieldName: "packagesValues", required: false, type: ForwardOffset<Vector<ForwardOffset<pahkat_Descriptor>, pahkat_Descriptor>>.self)
    _v.finish()
  }
}

